/**
 * @file SearchController.cs
 * @brief Manages the user interface logic for the search functionality.
 * @author (Github) IZH318 (https://github.com/IZH318)
 *
 * @details
 * This class encapsulates the logic for real-time search within the application. It decouples search-related
 * responsibilities from the main form, handling user input, debouncing, asynchronous searching, and updating
 * the search results data model. This approach improves code organization and maintains UI responsiveness
 * by employing an event-driven architecture.
 *
 * Key Features:
 *  - Decoupled Logic: Isolates search functionality from specific UI controls (MVVM-style).
 *  - Debounced Input: Uses a timer to delay search execution, preventing performance issues from rapid typing.
 *  - Asynchronous Searching: Performs search operations to keep the UI responsive.
 *  - Event Notifications: Notifies the view layer via events when results, status, or progress change.
 *
 * Technical Environment:
 *  - Target Framework: .NET Framework 4.8
 *  - Last Update: 2025-12-24
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace FSB_BANK_Extractor_Rebuilder_CS_GUI
{
    /// <summary>
    /// Manages the search functionality, including input handling, debouncing, and results generation.
    /// </summary>
    public class SearchController : IDisposable
    {
        #region 1. Constants & Configuration

        /// <summary>
        /// The delay in milliseconds before triggering a search after the user stops typing.
        /// </summary>
        private const int DEBOUNCE_INTERVAL_MS = 500;

        // UI Status Messages
        private const string MSG_READY = "[READY] Waiting for next operation.";
        private const string MSG_SEARCHING = "[SEARCH] Searching for matching items...";
        private const string MSG_NO_MATCH = "[SEARCH] No matching items found.";
        private const string MSG_NO_DATA = "[SEARCH] No data loaded.";
        private const string MSG_FOUND_FORMAT = "[SEARCH] Found {0} items.";

        // Default type name if node data is missing
        private const string TYPE_UNKNOWN = "Unknown";

        #endregion

        #region 2. Fields & Events

        /// <summary>
        /// Gets the list of search results generated by the last query.
        /// </summary>
        public List<SearchResultItem> Results { get; private set; } = new List<SearchResultItem>();

        /// <summary>
        /// Occurs when the search results have been updated and the UI should refresh.
        /// </summary>
        public event Action OnResultsUpdated;

        /// <summary>
        /// Occurs when the status message needs to be updated.
        /// </summary>
        public event Action<string> OnStatusChanged;

        /// <summary>
        /// Occurs when the progress state changes (isMarquee, max value).
        /// </summary>
        public event Action<bool, int> OnProgressChanged;

        /// <summary>
        /// A timer to debounce user input, delaying search execution to improve performance.
        /// </summary>
        private readonly Timer _debounceTimer;

        /// <summary>
        /// The search query currently waiting to be processed.
        /// </summary>
        private string _pendingQuery;

        /// <summary>
        /// The complete list of original TreeNodes that serves as the data source for searching.
        /// </summary>
        private List<TreeNode> _dataSource = new List<TreeNode>();

        #endregion

        #region 3. Initialization & Cleanup

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchController"/> class.
        /// </summary>
        public SearchController()
        {
            // Configure the debounce timer to prevent excessive search calls during typing.
            _debounceTimer = new Timer { Interval = DEBOUNCE_INTERVAL_MS };
            _debounceTimer.Tick += DebounceTimer_Tick;
        }

        /// <summary>
        /// Releases all resources used by the <see cref="SearchController"/>.
        /// </summary>
        public void Dispose()
        {
            _debounceTimer.Stop();
            _debounceTimer.Tick -= DebounceTimer_Tick;
            _debounceTimer.Dispose();
        }

        #endregion

        #region 4. Public Methods

        /// <summary>
        /// Sets the data source of original tree nodes to be used for searching.
        /// </summary>
        /// <param name="originalNodes">The list of root TreeNodes from the main view. Can be null.</param>
        public void SetDataSource(List<TreeNode> originalNodes)
        {
            _dataSource = originalNodes ?? new List<TreeNode>();
        }

        /// <summary>
        /// Updates the current search query and restarts the debounce timer.
        /// </summary>
        /// <param name="text">The text entered by the user to search for.</param>
        public void UpdateSearchText(string text)
        {
            _pendingQuery = text;

            // Reset the timer to delay execution until the user stops typing.
            _debounceTimer.Stop();
            _debounceTimer.Start();
        }

        /// <summary>
        /// Clears the search results and resets the UI state.
        /// </summary>
        public void ClearSearch()
        {
            Results.Clear();

            // Reset UI indicators to the ready state.
            OnStatusChanged?.Invoke(MSG_READY);
            OnProgressChanged?.Invoke(false, 0);
            OnResultsUpdated?.Invoke();
        }

        #endregion

        #region 5. Event Handlers & Search Logic

        /// <summary>
        /// Handles the Tick event of the _debounceTimer control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        private async void DebounceTimer_Tick(object sender, EventArgs e)
        {
            // Stop the timer immediately to prevent multiple triggers.
            _debounceTimer.Stop();

            // Execute the search logic asynchronously.
            await PerformSearchAsync(_pendingQuery);
        }

        /// <summary>
        /// Performs an asynchronous search based on the provided query and notifies listeners.
        /// </summary>
        /// <param name="query">The search string entered by the user.</param>
        private async Task PerformSearchAsync(string query)
        {
            string lowerQuery = query?.ToLower() ?? "";

            // Validate the query; if empty, clear the search state.
            if (string.IsNullOrWhiteSpace(lowerQuery))
            {
                ClearSearch();
                return;
            }

            // Notify the UI that a search operation is starting.
            OnStatusChanged?.Invoke(MSG_SEARCHING);
            OnProgressChanged?.Invoke(true, 0);

            // Check if there is data available to search.
            if (_dataSource.Count > 0)
            {
                // Execute the recursive search synchronously on the UI thread.
                // Accessing TreeNode properties (like Text) from a background thread via Task.Run 
                // causes cross-thread exceptions, so we perform this operation directly here.
                var matchedItems = new List<SearchResultItem>();
                SearchNodesRecursive(_dataSource, lowerQuery, matchedItems);

                Results = matchedItems;

                // Update the status message based on whether items were found.
                if (Results.Count > 0)
                {
                    OnStatusChanged?.Invoke(string.Format(MSG_FOUND_FORMAT, Results.Count));
                    OnProgressChanged?.Invoke(false, Results.Count);
                }
                else
                {
                    OnStatusChanged?.Invoke(MSG_NO_MATCH);
                    OnProgressChanged?.Invoke(false, 0);
                }
            }
            else
            {
                // Handle the case where the data source is empty or not loaded.
                Results.Clear();
                OnStatusChanged?.Invoke(MSG_NO_DATA);
                OnProgressChanged?.Invoke(false, 0);
            }

            // Notify listeners that the results list has been updated.
            OnResultsUpdated?.Invoke();

            // Yield execution to ensure the UI remains responsive during the update cycle.
            await Task.CompletedTask;
        }

        /// <summary>
        /// Recursively searches a collection of TreeNodes for matches against the search query.
        /// </summary>
        /// <param name="nodes">The collection of TreeNodes to search through.</param>
        /// <param name="query">The lowercased search query.</param>
        /// <param name="results">A list to which matched items will be added.</param>
        private void SearchNodesRecursive(IEnumerable<TreeNode> nodes, string query, List<SearchResultItem> results)
        {
            foreach (TreeNode node in nodes)
            {
                // Check if the node's text matches the query (case-insensitive).
                if (node.Text.ToLower().Contains(query))
                {
                    // Attempt to resolve the node type from its tag data.
                    string type = TYPE_UNKNOWN;
                    if (node.Tag is NodeData data)
                    {
                        type = data.Type.ToString();
                    }

                    results.Add(new SearchResultItem
                    {
                        Name = node.Text,
                        Type = type,
                        FullPath = node.FullPath,
                        Checked = node.Checked,
                        Tag = node // Store reference to original node for navigation.
                    });
                }

                // Continue the search into child nodes if they exist.
                if (node.Nodes.Count > 0)
                {
                    SearchNodesRecursive(node.Nodes.Cast<TreeNode>(), query, results);
                }
            }
        }

        #endregion
    }
}